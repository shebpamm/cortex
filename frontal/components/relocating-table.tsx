/**
 * This code was generated by v0 by Vercel.
 * @see https://v0.dev/t/gDj8jGpjaBq
 * Documentation: https://v0.dev/docs#integrating-generated-code-into-your-nextjs-app
 */

/** Add fonts into your Next.js project:

import { Inter } from 'next/font/google'

inter({
  subsets: ['latin'],
  display: 'swap',
})

To read more about using these font, please visit the Next.js documentation:
- App Directory: https://nextjs.org/docs/app/building-your-application/optimizing/fonts
- Pages Directory: https://nextjs.org/docs/pages/building-your-application/optimizing/fonts
**/
import {
  Table,
  TableHeader,
  TableRow,
  TableHead,
  TableBody,
  TableCell,
} from "@/components/ui/table";
import { Progress } from "@/components/ui/progress";
import { useState, useEffect } from "react";
import { ColumnDef } from "@tanstack/react-table";
import { DataTable, wrapSortable } from "./ui/data-table";

import prettyBytes from "pretty-bytes";
import { parseSize } from "@/lib/utils";
import { gql, useQuery } from "@apollo/client";
import { Button } from "./ui/button";
import {
  ContextMenu,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuTrigger,
} from "./ui/context-menu";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTrigger,
} from "./ui/dialog";
import { RelocatingHistogram } from "./relocating-histogram";

const GET_RELOCATING = gql`
  query relocating {
    relocating {
      index
      shard
      state
      ip
      store
      node
    }
  }
`;

export function RelocatingTable(props: { filter: string }) {
  const { data, loading } = useQuery(GET_RELOCATING);
  const [histogramOpen, setHistogramOpen] = useState(false);

  if (loading) {
    return <Progress />;
  }

  const columns: ColumnDef<any>[] = [
    {
      accessorKey: "index",
      header: wrapSortable.bind(null, "Index"),
    },
    {
      accessorKey: "state",
      header: wrapSortable.bind(null, "State"),
    },
    {
      accessorKey: "ip",
      header: wrapSortable.bind(null, "IP"),
    },
    {
      accessorKey: "store",
      header: wrapSortable.bind(null, "Store"),
      cell: ({ row }) => {
        if (!row.original.store) {
          return "N/A";
        }
        return prettyBytes(parseSize(row.original.store));
      },
      sortingFn: (a, b, direction) => {
        if (!a.original.store || !b.original.store) {
          return 0;
        }
        const sizeA = parseSize(a.original.store);
        const sizeB = parseSize(b.original.store);

        if (direction === "asc") {
          return sizeA - sizeB;
        } else {
          return sizeB - sizeA;
        }
      },
    },
    {
      accessorKey: "node",
      header: wrapSortable.bind(null, "Source"),
      cell: ({ row }) => {
        console.log(row.original);
        return (row.original.node.split("->")[0] || "").trim();
      },
      sortingFn: (a, b, direction) => {
        const nodeA = a.original.node.split("->")[0].trim();
        const nodeB = b.original.node.split("->")[0].trim();

        if (direction === "asc") {
          return nodeA.localeCompare(nodeB);
        } else {
          return nodeB.localeCompare(nodeA);
        }
      },
    },
    {
      accessorKey: "node",
      header: wrapSortable.bind(null, "Destination"),
      cell: ({ row }) => {
        return row.original.node.split(" ").reverse()[0];
      },
      sortingFn: (a, b, direction) => {
        const nodeA = a.original.node.split(" ").reverse()[0];
        const nodeB = b.original.node.split(" ").reverse()[0];

        if (direction === "asc") {
          return nodeA.localeCompare(nodeB);
        } else {
          return nodeB.localeCompare(nodeA);
        }
      },
    },
  ];

  let relocating;
  if (props.filter) {
    relocating = data.relocating.filter((r: any) =>
      JSON.stringify(r).includes(props.filter)
    );
  } else {
    relocating = data.relocating;
  }

  return (
    <>
      <Dialog open={histogramOpen} onOpenChange={() => setHistogramOpen(false)}>
        <DialogTrigger></DialogTrigger>
        <DialogContent
          className={"lg:max-w-screen-lg overflow-y-hide max-h-screen-80"}
        >
          <DialogHeader>Size distribution</DialogHeader>
          <RelocatingHistogram />
        </DialogContent>
      </Dialog>
      <ContextMenu>
        <ContextMenuTrigger>
          <div className="overflow-auto border rounded-lg">
            <DataTable columns={columns} data={data.relocating} />
          </div>
        </ContextMenuTrigger>
        <ContextMenuContent className="w-64">
          <ContextMenuItem inset onSelect={() => setHistogramOpen(true)}>
            Size Distribution
          </ContextMenuItem>
        </ContextMenuContent>
      </ContextMenu>
    </>
  );
}

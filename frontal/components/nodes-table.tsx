/**
 * This code was generated by v0 by Vercel.
 * @see https://v0.dev/t/gDj8jGpjaBq
 * Documentation: https://v0.dev/docs#integrating-generated-code-into-your-nextjs-app
 */

/** Add fonts into your Next.js project:

import { Inter } from 'next/font/google'

inter({
  subsets: ['latin'],
  display: 'swap',
})

To read more about using these font, please visit the Next.js documentation:
- App Directory: https://nextjs.org/docs/app/building-your-application/optimizing/fonts
- Pages Directory: https://nextjs.org/docs/pages/building-your-application/optimizing/fonts
**/
import {
  Table,
  TableHeader,
  TableRow,
  TableHead,
  TableBody,
  TableCell,
} from "@/components/ui/table";
import { Progress } from "@/components/ui/progress";
import { ColumnDef } from "@tanstack/react-table";
import { DataTable, wrapSortable } from "./ui/data-table";

import prettyBytes from "pretty-bytes";
import { gql, useQuery } from "@apollo/client";

function calculateDiskProgress(
  availableInBytes: number,
  totalInBytes: number,
): number {
  if (totalInBytes === 0) {
    return availableInBytes === 0 ? 100 : 0;
  }
  const progress = (1 - availableInBytes / totalInBytes) * 100;
  return progress;
}

const columns: ColumnDef<any>[] = [
  {
    accessorKey: "name",
    header: wrapSortable.bind(null, "Index"),
  },
  {
    accessorKey: "ip",
    header: wrapSortable.bind(null, "IP"),
  },
  {
    accessorKey: "attributes.storageType",
    header: wrapSortable.bind(null, "Storage Type"),
  },
  {
    accessorKey: "fs.total.totalInBytes",
    header: wrapSortable.bind(null, "Total"),
    cell: ({ row }) => {
      return prettyBytes(parseInt(row.original.fs.total.totalInBytes));
    },
  },
  {
    accessorKey: "fs.total.availableInBytes",
    header: wrapSortable.bind(null, "Available"),
    cell: ({ row }) => {
      return prettyBytes(parseInt(row.original.fs.total.availableInBytes));
    },
  },
  {
    accessorKey: "fs.total.availableInBytes",
    header: "Disk Usage",
    cell: ({ row }) => {
      return (
        <Progress
          value={calculateDiskProgress(
            row.original.fs.total.availableInBytes,
            row.original.fs.total.totalInBytes,
          )}
        />
      );
    },
  },
  {
    accessorKey: "process.cpu.percent",
    header: wrapSortable.bind(null, "CPU"),
    cell: ({ row }) => {
      return <Progress value={row.original.process.cpu.percent} />;
    },
  },
  {
    accessorKey: "os.mem.usedPercent",
    header: wrapSortable.bind(null, "Memory"),
    cell: ({ row }) => {
      return <Progress value={row.original.os.mem.usedPercent} />;
    },
  },
];

const GET_NODES = gql`
  query nodes {
    nodes {
      nodes {
        name
        ip
        attributes {
          machineMemory
          storageType
        }
        fs {
          total {
            totalInBytes
            freeInBytes
            availableInBytes
          }
        }
        process {
          cpu {
            percent
          }
        }
        os {
          mem {
            totalInBytes
            freeInBytes
            usedInBytes
            usedPercent
          }
        }
      }
    }
  }
`;

export function NodesTable() {
  const { loading, error, data } = useQuery(GET_NODES);

  if (loading) {
    return <Progress />;
  }

  if (error) {
    return <div>Error loading indices</div>;
  }

  return (
    <div className="overflow-auto border rounded-lg">
      <DataTable columns={columns} data={data.nodes.nodes} />
    </div>
  );
}

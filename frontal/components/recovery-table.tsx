/**
* This code was generated by v0 by Vercel.
* @see https://v0.dev/t/gDj8jGpjaBq
* Documentation: https://v0.dev/docs#integrating-generated-code-into-your-nextjs-app
*/

/** Add fonts into your Next.js project:

import { Inter } from 'next/font/google'

inter({
  subsets: ['latin'],
  display: 'swap',
})

To read more about using these font, please visit the Next.js documentation:
- App Directory: https://nextjs.org/docs/app/building-your-application/optimizing/fonts
- Pages Directory: https://nextjs.org/docs/pages/building-your-application/optimizing/fonts
**/
import { Table, TableHeader, TableRow, TableHead, TableBody, TableCell } from "@/components/ui/table"
import { Progress } from "@/components/ui/progress"
import { useState, useEffect } from "react"
import { ColumnDef } from "@tanstack/react-table"
import { DataTable, wrapSortable } from "./ui/data-table"

import prettyBytes from 'pretty-bytes';

export function RecoveryTable() {
  const [ recoveries, setRecoveries ] = useState([])

  useEffect(() => {
    const fetchShards = async () => {
      const response = await fetch("http://localhost:3030/elastic/recovery")
      const data = await response.json()
      setRecoveries(data)
    }
    fetchShards()
  }, [])

  const columns: ColumnDef<any>[] = [
    {
      accessorKey: "index",
      header: wrapSortable.bind(null, "Index"),
    },
    {
      accessorKey: "shard",
      header: wrapSortable.bind(null, "Shard"),
    },
    {
      accessorKey: "stage",
      header: wrapSortable.bind(null, "Stage"),
    },
    {
      accessorKey: "type",
      header: wrapSortable.bind(null, "Type"),
    },
    {
      accessorKey: "size",
      header: wrapSortable.bind(null, "Size"),
      cell: ({ row }) => {
        return prettyBytes(row.original.size)
      }
    },
    {
      accessorKey: "progress",
      header: wrapSortable.bind(null, "Progress"),
      cell: ({ row }) => {
        return <Progress value={row.original.progress} />
      }
    }
  ];

  const tableData = [];

  for (const indexName in recoveries) {
    const indexInfo: any = recoveries[indexName]
    const shards: any = indexInfo.shards
    for (const shard in shards) {
      const shardInfo = shards[shard]
      tableData.push({
        shard: shard,
        index: indexName,
        type: shardInfo.shard_type,
        stage: shardInfo.stage,
        size: shardInfo.index.size.total_in_bytes,
        progress: parseInt(shardInfo.index.files.percent.replace("%", "").trim())
      })
    }
  }

  return (
    <div className="overflow-auto border rounded-lg">
      <DataTable columns={columns} data={tableData} />
    </div>
  )
}
